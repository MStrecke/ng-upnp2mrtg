#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
######################################################################
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
######################################################################

# name/IP and port of router
DEFAULT_HOST = "192.168.0.1"
DEFAULT_PORT = 49300

# name of the box, used as is in html page generated by mrtg
DEFAULT_TARGET_NAME = "NetCologne Box"

# prints lots of stuff
DEBUG = False

import socket
import re
import getopt
import sys
import datetime

def dhms(sec):
    """ return number of seconds as (days,hours,minutes,seconds)
    """
    if sec is None: return (0,0,0,0)

    min = sec // 60
    sec %= 60
    ho = min // 60
    min %= 60
    day = ho // 24
    ho %= 24

    return (day, ho, min, sec)

def none2unknown(val):
    """ return value as is, except if value is None
        rrdtools/mrtg wants UNKNOWN in this case
    """
    if val is None: return "UNKNOWN"
    return val

def my_int(s, default = None):
    try:
        v = int(s)
    except ValueError:
        v = default
    return v

def response_code(msg):
    """ extract response code from HTTP response
         example: HTTP/1.1 200 OK
        -> 200: ok
        -> -1: error during decode
        -> any other is considered not ok
    """
    if msg is None: return 0

    match = re.match('^HTTP/1\.[0|1]\s+(\d+)',msg)
    if match is None: return 0
    return int(match.group(1))

def gettag(answer,tag):
    """ find <tag>result</tag> in answer
    """

    if (answer is None) or (tag is None): return None

    # extract part between <tag> and </tag>
    tag1 = "<%s>" % (tag,)
    tag2 = "</%s>" % (tag,)
    po1 = answer.find(tag1) + len(tag1)
    if po1<0 : return None      # opening tag not found
    po2 = answer.find(tag2,po1)
    if po2<0 : return None      # closing tag not found

    return answer[po1:po2]


class upnpclient(object):
    def __init__(self,host,port):
        self.host = host
        self.port = port

    def create_message(self,serviceurl,schema,action):
        body="""<?xml version="1.0"?>
    <s:Envelope
        xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
        s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
    <s:Body>
       <u:%s xmlns:u="urn:schemas-upnp-org:service:%s" />
    </s:Body>
</s:Envelope>""" % (action,schema)

        pream = """POST /%s HTTP/1.0
HOST: %s:%s
CONTENT-LENGTH: %s
CONTENT-TYPE: text/xml; charset="utf-8"
SOAPACTION: "urn:schemas-upnp-org:service:%s#%s"

""".replace("\n","\r\n") % (serviceurl,self.host,self.port,len(body),schema,action)

        dat = "%s%s" % (pream,body)

        return dat

    def send(self,cmd):
        """ send command to host:port and wait for the answer
        """

        # create TCP socket and connect to host:port
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.host,self.port))

        # send text
        s.send(cmd)

        # receive answer
        resp = ""
        while True:
            data = s.recv(1024)                 # receive up to 1K bytes
            if len(data) == 0: break
            resp += data
        s.close()

        return resp

    def send_command(self,serviceurl,schema,action,tag):
        """ send command to router and analyse the result
            returns the value between <tag> and </tag>
            or None on error

            tag can be a single string (in this case the function returns a string)
            or a tuple of strings (in this case a tuple of results is returned)
        """
        global DEBUG

        cmd = self.create_message(serviceurl,schema,action)
        if DEBUG: print cmd
        try:
            res = self.send(cmd)
        except socket.error, msg:
            print 'Socket error:', msg
            return None
        if DEBUG: print res

        # check return code
        ret_code = response_code(res)
        if DEBUG: print 'repsonse code:',ret_code
        if ret_code != 200: return None

        if tag is None: return res  # debug

        if type(tag) is tuple:
            answer = []
            for t in tag:
                answer.append( gettag(res,t) )
            if DEBUG: return answer
            return tuple(answer)
        else:
            if DEBUG: return gettag(res,tag)
            return gettag(res,tag)

class basic_modem(object):
    """ This is an abstract class
        overwrite the functions
    """
    def __init__(self):
        self.target_name = self.get_long_id()   # descriptive text for 4th line of output

    def get_id(self):
        """ returns a short if, which will be shown in --list
        """
        return "???"

    def get_long_id(self):
        """ returns longer description (model id, etc.)
        """
        return "?????"

    def query(self,host,port):
        # see mrtg-reference: External Monitoring Scripts
        # returns the value for the 4 strings
        # 1: variable 1, usually incoming bytes count
        # 2: variable 2, usually outgoing bytes count
        # 3: uptime in human readble format (string is displayed as is)
        #    query must format the string into human readable form
        # 4: name of target (string is displayed as is)
        #    set to long_id by __init__ - can be overwritten
        pass

class nc_router(basic_modem):
    def get_id(self):
        return "nc_premium"

    def get_long_id(self):
        return "NetCologn Premium"

    def query(self,host,port):
        uc = upnpclient(host,port)

        inbytes = uc.send_command("WANCommonInterfaceConfigService/control",
           "WANCommonInterfaceConfig:1",
           "GetTotalBytesReceived",
           "NewTotalBytesReceived")

        outbytes = uc.send_command("WANCommonInterfaceConfigService/control",
           "WANCommonInterfaceConfig:1",
           "GetTotalBytesSent",
           "NewTotalBytesSent")

        uptime = uc.send_command("WANIPConnectionService/control",   # controlurl
           "WANIPConnection:1",  # servicetype
           "GetStatusInfo",
           "NewUptime")

        try:
            uptime = int(uptime)
        except (ValueError,TypeError):
            uptime = None
        if uptime is None: uptime = 0

        uptime_str = "%s days %02d:%02d:%02d h" % dhms(uptime)
        return inbytes, outbytes, uptime_str, self.target_name

class fritzbox_7490(basic_modem):
    def get_id(self):
        return "fritzbox_7490"

    def get_long_id(self):
        return "Fritzbox 7490"

    def query(self,host,port):
        uc = upnpclient(host,port)

        inbytes = uc.send_command("igdupnp/control/WANCommonIFC1",
           "WANCommonInterfaceConfig:1",
           "GetTotalBytesReceived",
           "NewTotalBytesReceived")

        outbytes = uc.send_command("igdupnp/control/WANCommonIFC1",
           "WANCommonInterfaceConfig:1",
           "GetTotalBytesSent",
           "NewTotalBytesSent")

        uptime = uc.send_command("igdupnp/control/WANIPConn1",   # controlurl
           "WANIPConnection:1",  # servicetype
           "GetStatusInfo",
           "NewUptime")

        try:
            uptime = int(uptime)
        except (ValueError,TypeError):
            uptime = None
        if uptime is None: uptime = 0

        uptime_str = "%s days %02d:%02d:%02d h" % dhms(uptime)
        return inbytes, outbytes, uptime_str, self.target_name

class archer_c7(basic_modem):
    def get_id(self):
        return "archer_c7"

    def get_long_id(self):
        return "Tp-Link Archer C7"

    def query(self,host,port):
        uc = upnpclient(host,port)

        inbytes = uc.send_command("ifc",
           "WANCommonInterfaceConfig:1",
           "GetTotalBytesReceived",
           "NewTotalBytesReceived")

        outbytes = uc.send_command("ifc",
           "WANCommonInterfaceConfig:1",
           "GetTotalBytesSent",
           "NewTotalBytesSent")

        uptime = uc.send_command("ipc",   # controlurl
           "WANIPConnection:1",  # servicetype
           "GetStatusInfo",
           "NewUptime")
        # Expected uptime string: "103 Days, 12:49:51"

        uptime_str = uptime.split(" ")[0] + " days " + uptime.split(" ")[2] + " h"
        return inbytes, outbytes, uptime_str, self.target_name

###################################################
class nowrap_handler(object):
    # The last raw values from the device and the last offsets
    # are stored in a file.

    def __init__(self,filename):
        self.filename = filename
        self.lastinraw = None
        self.lastoutraw = None
        self.inoffset = 0
        self.outoffset = 0

        try:
            lines = open(filename,'r').readlines()
            if len(lines) != 2: raise ValueError,"format mismatch"

            comp = re.compile("^(\d+)\t(\d+)\n$")
            m1 = comp.match(lines[0])
            m2 = comp.match(lines[1])
            if (m1 is None) or (m2 is None): raise ValueError,"format mismatch"

            self.lastinraw = int(m1.group(1))
            self.lastoutraw = int(m1.group(2))
            self.inoffset = int(m2.group(1))
            self.outoffset = int(m2.group(2))
        except (IOError, ValueError):
            pass

    def __str__(self):
        return "%s\t%s\n%s\t%s\n" % (self.lastinraw, self  .lastoutraw, \
            self.inoffset, self.outoffset)

    def get_corr_values(self,newinraw,newoutraw):
        # - get corrected values
        # - store last values (if not None)
        # - calc new offset

        newinraw = my_int(newinraw,None)
        newoutraw = my_int(newoutraw,None)

        if not (newinraw is None):
            if newinraw < self.lastinraw:
                self.inoffset += self.lastinraw
            self.lastinraw = newinraw

            newinraw += self.inoffset

        if not (newoutraw is None):
            if newoutraw < self.lastoutraw:
                self.outoffset += self.lastoutraw
            self.lastoutraw = newoutraw

            newoutraw += self.outoffset

        return newinraw, newoutraw

    def store_info(self):
        f = open(self.filename,'w')
        f.write(str(self))
        f.close()

    def get_offsets(self):
        return self.inoffset, self.outoffset



############## command line interface #############

def usage():
    print """Usage: %s [OPTIONS]
--help        this message
--host, -h    host ip (default: %s)
--port. -p    port number (default: %s)
--type, -t    type of router (mandatory)
--list        list available router
--rawlog fnm  save raw data in file
--nowrap fnm  activate anti-wrap, store status in fnm
--debug       enter debug mode
""" % (sys.argv[0],DEFAULT_HOST,DEFAULT_PORT)

def list_models(all):
    if len(all) == 0:
        print "No models available"
        return
    print "Model id        Description"
    print "--------        -----------"

    for m in all:
        print "%-15s %s" % (m.get_id(), m.get_long_id())

def get_model(all,search):
    s = search.lower()
    for m in all:
        if m.get_id().lower() == s: return m
    return None

def main():
    global DEBUG

    allrouter = (nc_router(), fritzbox_7490(), archer_c7())

    hostip = DEFAULT_HOST
    portno = DEFAULT_PORT
    target_name = DEFAULT_TARGET_NAME
    selected_model = None
    rawlog = None
    nowrap = None

    try:
        opts, args = getopt.getopt(sys.argv[1:], "h:p:t:", ["help", "host=","port=","type=","list","debug","rawlog=","nowrap="])
    except getopt.GetoptError:
        print "unknown option"
        usage()
        sys.exit(2)

    for o, a in opts:
        if o == "--help":
            usage()
            sys.exit()
        if o == "--list":
            list_models(allrouter)
            sys.exit()
        if o == "--debug":
            DEBUG = True
        if o in ("-h", "--host"):
            hostip = a
        if o in ("-p", "--port"):
            portno = a
        if o in ("-t", "--type"):
            selected_model = get_model(allrouter, a)
        if o == "--rawlog":
            rawlog = a
        if o == "--nowrap":
            nowrap = nowrap_handler(a)

    if selected_model is None:
        print "Please select type of router.\n"
        list_models(allrouter)
        print
        usage()
        sys.exit(2)

    try:
        portno = int(portno)
    except ValueError:
        print "port must be integer"
        sys.exit(3)

    inbytes, outbytes, uptime, target = selected_model.query(hostip,portno)

    if not(nowrap is None):
        inbytes, outbytes = nowrap.get_corr_values(inbytes,outbytes)
        nowrap.store_info()

    # store raw data in a file (if requested)
    # give a hint in the output that will displayed in the HTML page

    if rawlog is None:
        logindicator = ''
    else:
        try:
            now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            if nowrap is None:
                add_info = ''
            else:
                di, do = nowrap.get_offsets()
                add_info = '\t%s\t%s' % (di,do)

            f = open(rawlog,'a')
            print >>f,'%s\t%s\t%s\t%s%s' % (now,inbytes,outbytes,uptime,add_info)
            f.close()
            logindicator = ' (logged)'
        except IOError:
            logindicator = ' (error during logging)'

    # output for MRTG
    print none2unknown(inbytes)
    print none2unknown(outbytes)
    print uptime
    print selected_model.get_long_id() + logindicator


if __name__ == "__main__":
    main()
